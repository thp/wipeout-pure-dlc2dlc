/**
 * WipEout Pure DLC Region Converter
 * Copyright 2021 Thomas Perl <m@thp.io>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 **/

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

/**
 * This is simply 8-round XTEA encryption.
 *
 * See also:
 *    https://en.wikipedia.org/wiki/XTEA
 *    https://cryptography.fandom.com/wiki/XTEA
 **/
static void
xtea8(uint32_t *genkey, const uint32_t *key)
{
    uint32_t v0 = genkey[0];
    uint32_t v1 = genkey[1];

    const uint32_t k = 0x9e3779b9;
    const uint32_t num_rounds = 8;

    uint32_t sum = 0;

    for (uint32_t i=0; i<num_rounds; ++i) {
        v0 += (((v1 << 4 ^ v1 >> 5) + v1) ^ (key[sum&3] + sum));
        sum += k;
        v1 += (((v0 << 4 ^ v0 >> 5) + v0) ^ (key[(sum>>11)&3] + sum));
    }

    genkey[0] = v0;
    genkey[1] = v1;
}

/**
 * This is a simple XOR encryption where the keystream is generated by
 * "encrypting" the constant 0x12345678 and the file offset (divided by
 * 8 bytes) with XTEA and the per-DLC 128-bit key (from keys.txt). This
 * allows starting decryption at any 8-byte offset within the file, but
 * we only support full-file (en|de)cryption here for simplicity.
 **/
static void
crypt_with_key(uint8_t *buffer, uint32_t buffer_length, const uint32_t *key)
{
    union {
        uint32_t u32[2];
        uint8_t u8[8];
    } genkey;

    for (uint32_t i=0; i<buffer_length; ++i) {
        if (i % 8 == 0) {
            genkey.u32[0] = 0x12345678;
            genkey.u32[1] = i / 8;
            xtea8(genkey.u32, key);
        }
        buffer[i] ^= genkey.u8[i % 8];
    }
}

struct WoPureDlcKey {
    char *name;
    uint8_t key[16];
    struct WoPureDlcKey *next;
} *keys = NULL;

struct PiWadReadCtx {
    const char *filename;
    uint8_t *buf;
    size_t len;
    const struct WoPureDlcKey *key;
};

#define KEY_REGION_CHAR(key) ((key)->name[2])
#define KEY_BASE_NAME(key) ((key)->name + 10)

static struct PiWadReadCtx
read_file(const char *filename)
{
    struct PiWadReadCtx result = { filename, NULL, 0, NULL };

    FILE *fp = fopen(filename, "rb");

    if (fp) {
        fseek(fp, 0, SEEK_END);

        result.len = ftell(fp);
        result.buf = malloc(result.len);

        fseek(fp, 0, SEEK_SET);
        if (fread(result.buf, result.len, 1, fp) != 1) {
            free(result.buf);
            result.buf = NULL;
            result.len = 0;
        }

        fclose(fp);
    }

    if (!result.buf) {
        printf("Could not open or read '%s'\n", filename);
    }

    return result;
}

int
main(int argc, char *argv[])
{
    printf(" __      ___      ___          _\n"
           " \\ \\    / (_)_ __| __|___ _  _| |_\n"
           "  \\ \\/\\/ /| | '_ \\ _|/ _ \\ || |  _|\n"
           "   \\_/\\_/ |_| .__/___\\___/\\_,_|\\__|\n"
           "            |_|  | _ \\_  _ _ _ ___\n"
           " DLC             |  _/ || | '_/ -_)\n"
           " Region          |_|  \\_,_|_| \\___|\n"
           " Converter    2021-05-29 <m@thp.io>\n"
           "\n");

    FILE *kfp = fopen("keys.txt", "r");
    char line[512];
    while (!feof(kfp)) {
        char *tmp = fgets(line, sizeof(line), kfp);
        if (tmp == NULL || *tmp == '\0' || *tmp == '#') {
            continue;
        }
        char *end = strchr(tmp, ' ');
        if (end == NULL) {
            continue;
        }
        *end = '\0';
        end++;
        while (*end == ' ') {
            ++end;
        }

        struct WoPureDlcKey *key = malloc(sizeof(struct WoPureDlcKey));

        key->next = keys;
        keys = key;

        key->name = strdup(tmp);

        for (size_t j=0; j<sizeof(key->key); ++j) {
            char *cur = end;
            end = strchr(cur, ' ');
            if (!end) {
                end = strchr(cur, '\n');
            }
            if (end == NULL) {
                printf("Could not parse keys.txt\n");
                return 1;
            }
            *end = '\0';
            key->key[j] = strtol(cur, NULL, 16);
            ++end;
        }
    }
    fclose(kfp);

    if (argc != 4) {
        printf("Usage: %s [PI.WAD] [DONOR.WAD] [OUT.WAD]\n"
               "\n"
               "  PI.WAD ........ The DLC pack you want to convert\n"
               "  DONOR.WAD ..... Any target region DLC from which we 'borrow' the signature\n"
               "  OUT.WAD ....... The region-converted, fake-signed output PI.WAD file\n"
               "\n"
               "This tool will convert downloadable content from one region\n"
               "to another, making it possible to use e.g. JPN- and USA-\n"
               "exclusive content with an EUR release of the game.\n"
               "\n",
               argv[0]
        );
        return 1;
    }

    char *source_filename = argv[1];
    char *target_filename = argv[2];
    char *out_filename = argv[3];

    enum { SOURCE = 0, DONOR, COUNT };

    struct PiWadReadCtx bufs[COUNT];

    bufs[SOURCE] = read_file(source_filename);
    bufs[DONOR] = read_file(target_filename);

    if (!bufs[SOURCE].buf || !bufs[DONOR].buf) {
        return 1;
    }

    struct WoPureDlcKey *key = keys;
    while (key != NULL) {
        for (int j=0; j<COUNT; ++j) {
            struct PiWadReadCtx *buf = &bufs[j];

            union {
                uint8_t u8[8];
                uint32_t version;
            } try_bytes;
            memcpy(try_bytes.u8, buf->buf, sizeof(try_bytes));

            crypt_with_key(try_bytes.u8, sizeof(try_bytes), (const uint32_t *)key->key);
            if (try_bytes.version == 1) {
                buf->key = key;
            }
        }

        key = key->next;
    }

    for (int j=0; j<COUNT; ++j) {
        struct PiWadReadCtx *buf = &bufs[j];
        if (!buf->key) {
            printf("Could not identify %s\n", buf->filename);
            return 1;
        }

        printf("Detected %-6s pack: %-12s (Region: %c)\n",
                (j==SOURCE)?"source":"donor",
                KEY_BASE_NAME(buf->key),
                KEY_REGION_CHAR(buf->key));
    }

    if (KEY_REGION_CHAR(bufs[SOURCE].key) == KEY_REGION_CHAR(bufs[DONOR].key)) {
        printf("%s is already in region %c.\n",
                bufs[SOURCE].filename,
                KEY_REGION_CHAR(bufs[DONOR].key));
        return 1;
    }

    if (KEY_REGION_CHAR(bufs[SOURCE].key) == 'E') {
        printf("Cannot convert EUR content to USA/JAP, because it uses zlib compression.\n");
        return 1;
    }

    const size_t SIG_SIZE = 256;

    printf("Decrypting WAD... (%zu bytes)\n", bufs[SOURCE].len - SIG_SIZE);
    crypt_with_key(bufs[SOURCE].buf, bufs[SOURCE].len - SIG_SIZE, (const uint32_t *)bufs[SOURCE].key->key);

    struct WadHeader {
        uint32_t version;
        uint32_t nitems;
    } *wad_header = (struct WadHeader *)bufs[SOURCE].buf;

    if (wad_header->version == 1) {
        printf("WAD contents: %u entries\n", wad_header->nitems);
    } else {
        printf("Decrypting failed\n");
        return 1;
    }

    printf("Borrowing fake signature... (%zu bytes)\n", SIG_SIZE);
    memcpy(bufs[SOURCE].buf + bufs[SOURCE].len - SIG_SIZE,
           bufs[DONOR].buf + bufs[DONOR].len - SIG_SIZE,
           SIG_SIZE);

    printf("Encryping WAD... (%zu bytes)\n", bufs[SOURCE].len - SIG_SIZE);
    crypt_with_key(bufs[SOURCE].buf, bufs[SOURCE].len - SIG_SIZE, (const uint32_t *)bufs[DONOR].key->key);

    printf("Writing to %s... (%zu bytes)\n", out_filename, bufs[SOURCE].len);
    FILE *fp = fopen(out_filename, "wb");
    if (!fp) {
        printf("Could not open '%s' for writing\n", out_filename);
        return 1;
    }

    if (fwrite(bufs[SOURCE].buf, bufs[SOURCE].len, 1, fp) != 1) {
        printf("Could not write converted DLC to '%s'\n", out_filename);
    }
    fclose(fp);

    char region_prefix[10];
    memcpy(region_prefix, bufs[DONOR].key->name, 9);
    region_prefix[9] = '\0';

    printf("\n"
           "Success! Copy the output file to\n"
           "    PSP/SAVEDATA/%s%s/PI.WAD\n"
           "on your memory stick.\n"
           "Do not forget to disable DLC signature checks via cheats!\n",
           region_prefix, bufs[SOURCE].key->name + 9);

    for (int j=0; j<COUNT; ++j) {
        free(bufs[j].buf);
    }

    return 0;
}
